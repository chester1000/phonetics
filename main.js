// Generated by CoffeeScript 1.9.3
(function() {
  var DEFAULT_THEME;

  DEFAULT_THEME = 'indigo';

  angular.module('phoneticsApp', ['ngMaterial', 'angularRipple']).config(function($sceDelegateProvider, $locationProvider, $mdThemingProvider) {
    var j, len, results1, t, themes;
    $sceDelegateProvider.resourceUrlWhitelist(['self', 'http://files.parsetfss.com/**']);
    $locationProvider.html5Mode(true);
    $mdThemingProvider.alwaysWatchTheme(true);
    themes = [
      {
        primary: DEFAULT_THEME,
        accent: 'pink'
      }, {
        primary: 'light-green',
        accent: 'pink'
      }, {
        primary: 'light-blue',
        accent: 'orange'
      }, {
        primary: 'amber',
        accent: 'blue'
      }, {
        primary: 'teal',
        accent: 'deep-purple'
      }, {
        primary: 'red',
        accent: 'green'
      }
    ];
    results1 = [];
    for (j = 0, len = themes.length; j < len; j++) {
      t = themes[j];
      results1.push($mdThemingProvider.theme(t.primary).primaryPalette(t.primary).accentPalette(t.accent));
    }
    return results1;
  }).service('ParseServ', function(utils) {
    var Langs, Sounds;
    Parse.initialize('BdvYraypXe3U33UV5mGBRgPmqC2xUyPoP54QgkML', 'kY4MCB6NyGtXjEY6TeAtFWr1zhLv377L3HIiBbas');
    Langs = Parse.Object.extend('Languages');
    Sounds = Parse.Object.extend('Sounds');
    this.getLangs = function(cb) {
      var query;
      query = new Parse.Query(Langs);
      return query.find({
        success: function(results) {
          return cb(null, results.map(function(r) {
            var palette;
            palette = r.get('palette');
            return {
              id: r.id,
              name: r.get('name'),
              originalName: r.get('originalName'),
              code: r.get('code'),
              palette: palette,
              color: utils.getColor(palette, 'A200')
            };
          }));
        },
        error: function(err) {
          return cb(err, []);
        }
      });
    };
    this.getSounds = function(langId, cb) {
      var query;
      query = new Parse.Query(Sounds);
      query.equalTo('language', langId);
      return query.find({
        success: function(results) {
          return cb(null, results.map(function(r) {
            var sound, soundName, soundNameUrl, soundUrl;
            sound = r.get('sound');
            soundUrl = sound != null ? sound.url() : void 0;
            soundName = r.get('soundName');
            soundNameUrl = soundName != null ? soundName.url() : void 0;
            return {
              name: r.get('name'),
              altNames: r.get('altNames'),
              sound: soundUrl,
              soundName: soundNameUrl
            };
          }));
        },
        error: function(err) {
          return cb(err, []);
        }
      });
    };
    return this;
  }).service('measurer', function($window) {
    var _panelChangeListeners, currentPanel, panels;
    _panelChangeListeners = [];
    panels = [];
    currentPanel = 0;
    return {
      getToolbarHeight: function() {
        return 64;
      },
      getWindowHeight: function() {
        return $window.innerHeight;
      },
      getViewPortHeight: function() {
        return this.getWindowHeight() - this.getToolbarHeight();
      },
      onPanelChange: function(callback) {
        return _panelChangeListeners.push(callback);
      },
      initPanels: function(pre) {
        pre.unshift({
          name: 'langs',
          height: this.getViewPortHeight()
        });
        return panels = pre;
      },
      setSize: function(name, height) {
        var j, len, results1, s;
        results1 = [];
        for (j = 0, len = panels.length; j < len; j++) {
          s = panels[j];
          if (s.name === name) {
            results1.push(s.height = height);
          }
        }
        return results1;
      },
      getBreakPoints: function() {
        return panels.reduce((function(p, c, i) {
          p.push(c.height + p[i]);
          return p;
        }), [0]);
      },
      getCurrentPanelInfo: function() {
        var _guessedPanel, b, bottom, breakpoints, cb, i, j, k, len, len1, screenMiddle, scrollToPoint, top;
        _guessedPanel = null;
        scrollToPoint = false;
        top = $window.scrollY;
        bottom = top + this.getViewPortHeight();
        breakpoints = this.getBreakPoints();
        for (i = j = 0, len = breakpoints.length; j < len; i = ++j) {
          b = breakpoints[i];
          if (i + 1 < breakpoints.length) {
            if (top >= b && bottom <= breakpoints[i + 1]) {
              _guessedPanel = i;
              break;
            } else if (top < b && bottom > b) {
              screenMiddle = top + this.getViewPortHeight() / 2;
              if (screenMiddle < b) {
                _guessedPanel = i - 1;
                scrollToPoint = breakpoints[_guessedPanel];
                if (panels[i - 1].height > this.getViewPortHeight()) {
                  scrollToPoint = breakpoints[i] - this.getViewPortHeight();
                }
              } else if (screenMiddle >= b) {
                _guessedPanel = i;
                scrollToPoint = breakpoints[i];
              }
              break;
            }
          }
        }
        if (_guessedPanel !== currentPanel) {
          currentPanel = _guessedPanel;
          for (k = 0, len1 = _panelChangeListeners.length; k < len1; k++) {
            cb = _panelChangeListeners[k];
            cb(currentPanel);
          }
        }
        return scrollToPoint;
      }
    };
  }).controller('LangCtrl', function($scope, ParseServ, measurer, utils, $rootScope) {
    var setStuff;
    $scope.soundNameInstead = false;
    setStuff = function(theme, title) {
      $scope.title = title;
      $scope.dynamicTheme = theme;
      return $rootScope.currentThemeColor = utils.getColor(theme);
    };
    setStuff(DEFAULT_THEME);
    measurer.onPanelChange(function(newGridIdx) {
      var c;
      if (newGridIdx === 0) {
        setStuff(DEFAULT_THEME);
      } else {
        c = $scope.langs[newGridIdx - 1];
        setStuff(c.palette, c.name);
      }
      return $scope.$apply();
    });
    return ParseServ.getLangs(function(err, langs) {
      var v;
      measurer.initPanels((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = langs.length; j < len; j++) {
          v = langs[j];
          results1.push({
            name: v.code
          });
        }
        return results1;
      })());
      $scope.langs = langs;
      return $scope.$apply();
    });
  }).controller('SoundBoardCtrl', function($scope, ParseServ, utils) {
    var lang;
    $scope.normalizedSoundName = function(sound) {
      return utils.normalize(sound.name);
    };
    lang = new Parse.Object('Languages');
    lang.id = $scope.lang.id;
    return ParseServ.getSounds(lang, function(err, sounds) {
      $scope.sounds = sounds;
      return $scope.$apply();
    });
  }).directive('aSound', function() {
    return {
      restrict: 'A',
      link: function(scope, element, attr) {
        var player;
        scope.playing = false;
        player = element.find('audio')[0];
        return element.on('click', function() {
          scope.playing = true;
          player.currentTime = 0;
          player.play();
          return player.addEventListener('ended', function() {
            scope.playing = false;
            return scope.$apply();
          });
        });
      }
    };
  }).directive('aPanel', function(measurer, $window, utils) {
    return {
      restrict: 'A',
      link: function(scope, el, attr) {
        var calculateHeight, debouncedCalculate;
        calculateHeight = function() {
          var idx, minHeight, ref;
          minHeight = Math.max(measurer.getViewPortHeight(), el[0].clientHeight);
          if (attr.lastHeight !== minHeight) {
            attr.$set('lastHeight', minHeight);
            idx = (ref = scope.lang) != null ? ref.code : void 0;
            if (!idx && scope.langs) {
              idx = 'langs';
            }
            if (idx == null) {
              idx = 'about';
            }
            measurer.setSize(idx, minHeight);
            el.css('min-height', minHeight + 'px');
          }
        };
        scope.setMinHeight = calculateHeight;
        debouncedCalculate = utils.debounce(100, calculateHeight);
        return angular.element($window).bind('resize', function() {
          el.css('min-height', '0px');
          return debouncedCalculate();
        });
      }
    };
  }).directive('snap', function($window, utils, measurer) {
    return function(scope, element, attrs) {
      var debouncedScroll;
      debouncedScroll = utils.debounce(100, function() {
        var scrollToPoint;
        scrollToPoint = measurer.getCurrentPanelInfo();
        if (scrollToPoint !== false) {
          return utils.scrollTo(scrollToPoint, 200, utils.easingFunctions.easeInOutQuint);
        }
      });
      return angular.element($window).bind('scroll', function() {
        measurer.getCurrentPanelInfo();
        return debouncedScroll();
      });
    };
  });

}).call(this);
